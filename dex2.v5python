{"mode":"Text","hardwareTarget":"brain","textContent":"#-----------------------------------------------------------------------------*/\n#                                                                             */\n#     Module:       Thresher Main Code                                        */\n#     Authors:      Thamer                                                    */\n#     Forked From:  https://github.com/jpearman/v5-drivecode                  */\n#     Created:      Sun Jan 12 2025                                           */\n#     Description:  Default code for Basking VeXU Robot - Python              */\n#     API Ref:      https://api.vex.com/v5/home/python/index.html             */\n#                                                                             */\n#-----------------------------------------------------------------------------*/\n\n# Library imports\nfrom vex import *\n\n# Brain should be defined by default\nbrain = Brain()\n\n# We define motors we want to use here \n# we use the motor variable to display statistics later\nmotor_11 = Motor(Ports.PORT11, GearSetting.RATIO_6_1, False) # left\nmotor_12 = Motor(Ports.PORT12, GearSetting.RATIO_6_1, False) # left\nmotor_13 = Motor(Ports.PORT13, GearSetting.RATIO_6_1, True) # left - top\nmotor_14 = Motor(Ports.PORT14, GearSetting.RATIO_6_1, True) # left - top\n\nmotor_20 = Motor(Ports.PORT20, GearSetting.RATIO_6_1, True) # right\nmotor_19 = Motor(Ports.PORT19, GearSetting.RATIO_6_1, True) # right\nmotor_18 = Motor(Ports.PORT18, GearSetting.RATIO_6_1, False) # right - top\nmotor_17 = Motor(Ports.PORT17, GearSetting.RATIO_6_1, False) # right - top\n\n\nmotor_01 = Motor(Ports.PORT1, GearSetting.RATIO_6_1, False)\nmotor_10 = Motor(Ports.PORT10, GearSetting.RATIO_18_1, True) \n\nmotor_8 = Motor(Ports.PORT8, GearSetting.RATIO_36_1, True) \nmotor_7 = Motor(Ports.PORT7, GearSetting.RATIO_36_1, False) \n\n\nmotor_05 = Motor(Ports.PORT5, GearSetting.RATIO_18_1, False)\nmotor_06 = Motor(Ports.PORT6, GearSetting.RATIO_18_1, False)\n\n\n# wait for all motors and sensors to fully initialize\nwait(30, MSEC)\n\n# The controller\ncontroller_1 = Controller(ControllerType.PRIMARY)\n\n\n# Assign generic motor to more useful names\nright_drive_1 = motor_20\nright_drive_2 = motor_19\nright_drive_3 = motor_18\nright_drive_4 = motor_17\n\nleft_drive_1 =  motor_11\nleft_drive_2 = motor_12\nleft_drive_3 = motor_13\nleft_drive_4 = motor_14\n\nlift_left = motor_8\nlift_right = motor_7\n\nintake_roller = motor_01\nchain_and_hook = motor_10\n\nintake_roller.set_velocity(500, RPM)\nchain_and_hook.set_velocity(200, RPM)\n\n# Max motor speed (percent) for motors controlled by buttons\nMAX_RPM = 24 # percent \nMAX_SPEED_INTAKE = 200\nMAX_SPEED_ROLLER = 70\nmogo_clamp_on = True\nclimb_hook_on = True\nmouth_open = False\nintake_on = False\n\n#-----------------------------------------------------------------------------*/\n#   @brief  Drive task                                                        */\n#-----------------------------------------------------------------------------*/\n#\n# All motors are controlled from this function which is run as a separate thread\n# Axis doc\n# https://api.vex.com/v5/home/python/Controller/Controller.Axis.html\n# axis1 - Left and right of the right joystick.\n# axis2 - Up and down of the right joystick.\n# axis3 - Up and down of the left joystick.\n# axis4 - Left and right of the left joystick.\n\ndef climb_hook_button_pressed():\n    global climb_hook_on\n    climb_hook_on = not climb_hook_on\n    three_wire_mogo_clamp = DigitalOut(brain.three_wire_port.h)\n    three_wire_mogo_clamp.set(climb_hook_on)\n    return \n\n\ndef mogo_clamp_button_pressed():\n    global mogo_clamp_on\n    mogo_clamp_on = not mogo_clamp_on\n    three_wire_mogo_clamp = DigitalOut(brain.three_wire_port.g)\n    three_wire_mogo_clamp.set(mogo_clamp_on)\n    return \n\ndef mouth_button_pressed():\n    global mouth_open\n    mouth_open = not mouth_open\n    three_wire_mouth = DigitalOut(brain.three_wire_port.g)\n    three_wire_mouth.set(mouth_open)\n\n\ndef intake_toggle_button_pressed():\n    global intake_on\n    intake_on = not intake_on    \n    return \n\n\n# special buttons events\n# controller_1.buttonY.pressed(mouth_button_pressed)\ncontroller_1.buttonDown.pressed(mogo_clamp_button_pressed)\ncontroller_1.buttonUp.pressed(climb_hook_button_pressed)\ncontroller_1.buttonY.pressed(intake_toggle_button_pressed)\n\ndef drive_task():\n    drive_left = 0\n    drive_right = 0\n\n    # loop forever\n    while True:\n        # buttons\n        chain_and_hook_m_12 = (controller_1.buttonR1.pressing() - controller_1.buttonL1.pressing()) * MAX_SPEED_INTAKE\n        intake_roller_m_19 = (controller_1.buttonR1.pressing() - controller_1.buttonL1.pressing()) * MAX_SPEED_ROLLER\n\n        drive_lift = (controller_1.buttonR2.pressing() - controller_1.buttonL2.pressing()) * MAX_RPM\n\n        drive_left =  (controller_1.axis3.position() - controller_1.axis1.position()) * MAX_RPM\n        drive_right = (controller_1.axis3.position() + controller_1.axis1.position()) * MAX_RPM\n\n        # threshold the variable channels so the drive does not\n        # move if the joystick axis does not return exactly to 0\n        deadband = 15\n        if abs(drive_left) < deadband:\n            drive_left = 0\n        if abs(drive_right) < deadband:\n            drive_right = 0\n\n        # The drivetrain\n        left_drive_1.spin(FORWARD, drive_left * .5, PERCENT)\n        right_drive_1.spin(FORWARD, drive_right * .5, PERCENT)\n\n        left_drive_2.spin(FORWARD, drive_left * .5, PERCENT)\n        right_drive_2.spin(FORWARD, drive_right * .5, PERCENT)\n\n        left_drive_3.spin(FORWARD, drive_left * .5, PERCENT)\n        right_drive_3.spin(FORWARD, drive_right * .5, PERCENT)\n\n        left_drive_4.spin(FORWARD, drive_left * .5, PERCENT)\n        right_drive_4.spin(FORWARD, drive_right * .5, PERCENT)\n\n        # intake roller + chain and hook\n        # if intake is toggled on spin forever\n        # if intake_on == True:\n        #     chain_and_hook.spin(FORWARD, -100, PERCENT)\n        #     intake_roller.spin(FORWARD, -100, PERCENT)\n        # else:\n        #     if controller_1.buttonL2.pressing() or controller_1.buttonR2.pressing():\n        #         chain_and_hook2 = (controller_1.buttonR2.pressing() - controller_1.buttonL2.pressing()) * MAX_SPEED_INTAKE\n        #         chain_and_hook.spin(FORWARD, chain_and_hook2, PERCENT)\n        #     else:\n        #         chain_and_hook.spin(FORWARD, chain_and_hook_m_12, PERCENT)\n        #         intake_roller.spin(FORWARD, intake_roller_m_19, PERCENT)\n\n        chain_and_hook.spin(FORWARD, chain_and_hook_m_12, PERCENT)\n        intake_roller.spin(FORWARD, intake_roller_m_19, PERCENT)\n\n        if controller_1.buttonR2.pressing() or controller_1.buttonL2.pressing():\n            lift_left.spin(FORWARD, drive_lift, PERCENT)\n            lift_right.spin(FORWARD, drive_lift, PERCENT)\n        else:\n            lift_left.stop(BRAKE)\n            lift_right.stop(BRAKE)\n\n        # No need to run too fast\n        # sleep(15)\n\n\n#------------------------------------------------------------------------------*/\n#   @brief      Display data for one motor                                     */\n#------------------------------------------------------------------------------*/\n\n# define some more colors\ngrey = Color(0x202020)\ndgrey = Color(0x2F4F4F)\nlblue = Color(0x303060)\nlred = Color(0x603030)\n\ndef displayMotorData(m, index):\n    ypos = 0\n    xpos = index * 48\n\n    # The actual velocity of the motor in rpm\n    v2 = m.velocity(RPM)\n\n    # The position of the motor internal encoder in revolutions\n    pos = m.position(TURNS)\n\n    # Motor current in Amps\n    c1 = m.current()\n\n    # Motor temperature\n    t1 = m.temperature()\n\n    brain.screen.set_font(FontType.MONO15)\n\n    # background color based on\n    # device and whether it's left, right or other motor\n    if not m.installed():\n        brain.screen.set_fill_color(grey)\n    elif m == left_drive_1 or m == left_drive_2:\n        brain.screen.set_fill_color(lblue)\n    elif m == right_drive_1 or m == right_drive_2:\n        brain.screen.set_fill_color(lred)\n    else:\n        brain.screen.set_fill_color(dgrey)\n\n    # Draw outline for motor info\n    brain.screen.set_pen_color(Color.WHITE)\n    w = 49 if index < 9 else 48\n    brain.screen.draw_rectangle(xpos, ypos, w, 79)\n\n    # no motor, then return early\n    if not m.installed():\n        brain.screen.print_at(\"NC\", x=xpos+15, y=ypos+30)\n        return\n\n    # we have no way to get command value in Python VM 1.0.0b20\n    # so have to deviate from C++ version, just show port number\n    brain.screen.print_at(\"%02d\" % (index+1), x=xpos+13, y=ypos+13)\n\n    # Show actual speed\n    brain.screen.set_pen_color(Color.YELLOW)\n    brain.screen.print_at(\"%4d\" % v2, x=xpos+13, y=ypos+30)\n\n    # Show position\n    brain.screen.print_at(\"%5.1f\" % pos, x=xpos+5, y=ypos+45)\n\n    # Show current\n    brain.screen.print_at(\"%4.1fA\" % c1, x=xpos+5, y=ypos+60)\n\n    # Show temperature\n    brain.screen.print_at(\"%4.0fC\" % t1, x=xpos+5, y=ypos+75)\n\n    brain.screen.set_pen_color(Color.WHITE)\n    brain.screen.draw_line(xpos, ypos+14, xpos+48, ypos+14)\n\n#-----------------------------------------------------------------------------*/\n#   @brief  Display task - show some useful motor data                        */\n#-----------------------------------------------------------------------------*/\n\ndef display_task():\n    brain.screen.set_font(FontType.PROP20)\n    brain.screen.set_pen_color(Color.RED)\n    brain.screen.print_at(\"TEST DRIVE CODE\", x=90, y=160)\n\n    motors = [motor_01,\n              motor_12,\n              motor_13,\n              motor_20,\n              motor_13,\n              motor_06,\n              motor_11,\n              motor_12,\n              motor_19,\n              motor_18]\n\n    while True:\n        index = 0\n        for m in motors:\n            displayMotorData(m, index)\n            index = index+1\n\n        # display using back buffer, stops flickering\n        brain.screen.render()\n\n        sleep(10)\n\n# Run the display code\ndisplay = Thread(display_task)\n\n\ndef setVelocity(percentage):\n    right_drive_1.set_velocity(percentage, PERCENT)\n    right_drive_2.set_velocity(percentage, PERCENT)\n    right_drive_3.set_velocity(percentage, PERCENT)\n    left_drive_1.set_velocity(percentage, PERCENT)\n    left_drive_2.set_velocity(percentage, PERCENT)\n    left_drive_3.set_velocity(percentage, PERCENT)\n\n\ndef rightGearsMove(direction, percentage):\n    right_drive_1.spin(direction, percentage, PERCENT)\n    right_drive_2.spin(direction, percentage, PERCENT)\n    right_drive_3.spin(direction, percentage, PERCENT)\n\ndef leftGearsMove(direction, percentage):\n    left_drive_1.spin(direction, percentage, PERCENT)\n    left_drive_2.spin(direction, percentage, PERCENT)\n    left_drive_3.spin(direction, percentage, PERCENT)\n\ndef allIntakes(direction, percentage):\n    intake_roller.spin(direction, percentage, PERCENT)\n    chain_and_hook.spin(direction, percentage, PERCENT)\n\ndef autonomous_task():\n    brain.screen.print(\"Auton Started\")\n    three_wire_mogo_clamp_auton = DigitalOut(brain.three_wire_port.h)\n\n    # open piston\n    three_wire_mogo_clamp_auton.set(True)\n    brain.screen.set_cursor(3, 1)\n    brain.screen.print(\"Back Piston: Opened\")\n\n    rightGearsMove(REVERSE, 35)\n    leftGearsMove(REVERSE, 35)\n    wait(1.4, SECONDS)  # Move backward for 1.8 seconds\n\n    # Gradual stop of motors after moving backward\n    rightGearsMove(REVERSE, 0)\n    leftGearsMove(REVERSE, 0)\n    wait(0.2, SECONDS)  # Wait for 0.5 seconds\n\n\n \n    rightGearsMove(FORWARD, 35)\n    leftGearsMove(REVERSE, 35)\n    wait(0.4, SECONDS)  # Move backward for 1.8 seconds\n\n    # Gradual stop of motors after moving backward\n    rightGearsMove(FORWARD, 0)\n    leftGearsMove(REVERSE, 0)\n    wait(0.2, SECONDS)\n\n\n    rightGearsMove(REVERSE, 35)\n    leftGearsMove(REVERSE, 35)\n    wait(0.6, SECONDS)  # Move backward for 1.8 seconds\n\n    # Gradual stop of motors after moving backward\n    rightGearsMove(REVERSE, 0)\n    leftGearsMove(REVERSE, 0)\n    wait(0.2, SECONDS)  # Wait for 0.5 seconds\n\n    rightGearsMove(REVERSE, 35)\n    leftGearsMove(FORWARD, 35)\n    wait(0.4, SECONDS)  # Move backward for 1.8 seconds\n\n    # Gradual stop of motors after moving backward\n    rightGearsMove(REVERSE, 0)\n    leftGearsMove(FORWARD, 0)\n    wait(0.2, SECONDS)\n\n\n    rightGearsMove(REVERSE, 35)\n    leftGearsMove(REVERSE, 35)\n    wait(0.6, SECONDS)  # Move backward for 1.8 seconds\n\n    # Gradual stop of motors after moving backward\n    rightGearsMove(REVERSE, 0)\n    leftGearsMove(REVERSE, 0)\n    wait(0.2, SECONDS)  # Wait for 0.5 seconds\n\n\n    three_wire_mogo_clamp_auton.set(False)  # Close the pneumatic system\n    brain.screen.set_cursor(3, 1)\n    brain.screen.print(\"Back Piston: Closed\")\n\n    allIntakes(REVERSE, 100) \n    wait(1.4, SECONDS) \n\n    rightGearsMove(REVERSE, 35)\n    leftGearsMove(FORWARD, 35)\n    wait(0.1, SECONDS)  # Move backward for 1.8 seconds\n\n    # Gradual stop of motors after moving backward\n    rightGearsMove(REVERSE, 0)\n    leftGearsMove(FORWARD, 0)\n    wait(0.2, SECONDS)\n\n\n    rightGearsMove(FORWARD, 30)\n    leftGearsMove(FORWARD, 30)\n    wait(1.3, SECONDS)  \n\n    rightGearsMove(FORWARD, 0)\n    leftGearsMove(FORWARD, 0)\n    wait(0.3, SECONDS)\n\n \n    allIntakes(REVERSE, 100) \n    wait(1, SECONDS) \n\n    rightGearsMove(FORWARD, 35)\n    leftGearsMove(REVERSE, 35)\n    wait(0.2, SECONDS)  # Move backward for 1.8 seconds\n\n    # Gradual stop of motors after moving backward\n    rightGearsMove(FORWARD, 0)\n    leftGearsMove(REVERSE, 0)\n    wait(0.2, SECONDS)\n\n\n    rightGearsMove(FORWARD, 30)\n    leftGearsMove(FORWARD, 30)\n    wait(1.2, SECONDS)  \n\n    rightGearsMove(FORWARD, 0)\n    leftGearsMove(FORWARD, 0)\n    wait(0.2, SECONDS)\n\n    allIntakes(REVERSE, 100) \n    wait(1.8, SECONDS)  \n\n    wait(0.2, SECONDS)  # Wait for 2 second to allow the pneumatic to activate\n\n\n    drive_task()\n\ncomp = Competition(drive_task, autonomous_task)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.62.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null}}