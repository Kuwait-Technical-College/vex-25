{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\nimport math\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n#-----------------------------------------------------------------------------#\n#     dex2 Main Code                                                          #\n#     Author: Fouad                                                           #\n#     Forked From: https://github.com/jpearman/v5-drivecode                  #\n#     Created: Nov 29, 2025                                                    #\n#     Description: Default code for dex2 VeXU Robot - Python                 #\n#-----------------------------------------------------------------------------#\n\nfrom vex import *\nimport urandom\nimport math\n\n# Initialize Brain and Controller\nbrain = Brain()\ncontroller_1 = Controller(ControllerType.PRIMARY)\n\n# Constants\nMAX_RPM = 100\nDEADBAND = 15\n\n# Colors\nCOLORS = {\n    \"grey\": Color(0x202020),\n    \"dgrey\": Color(0x2F4F4F),\n    \"lblue\": Color(0x303060),\n    \"lred\": Color(0x603030)\n}\n\n# Initialize Motors\nmotors = {\n    \"left_drive\": Motor(Ports.PORT2, GearSetting.RATIO_18_1, False),\n    \"right_drive\": Motor(Ports.PORT3, GearSetting.RATIO_18_1, True),\n    \"front_intake\": Motor(Ports.PORT10, GearSetting.RATIO_18_1, False),\n    \"top_roller\": Motor(Ports.PORT13, GearSetting.RATIO_18_1, True)\n}\n\nfor motor in motors.values():\n    motor.set_velocity(200, RPM)\n\n# Random Seed Initialization\ndef initialize_random_seed():\n    wait(100, MSEC)\n    seed = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(seed))\n\ninitialize_random_seed()\n\n# Console Setup\nwait(200, MSEC)\nprint(\"\\033[2J\")\n\n# --- NEW CUBIC DRIVE FUNCTION ---\ndef cubic_drive(input_value):\n    \"\"\"\n    Applies a cubic curve to the joystick input for smoother control.\n    input_value is expected to be between -100 and 100.\n    \"\"\"\n    fraction = input_value / 100.0\n    output = fraction * fraction * fraction * 100.0\n    return int(round(output))\n\n\n# Drive Logic\ndef get_drive_values():\n    axis3 = controller_1.axis3.position()\n    axis1 = - controller_1.axis1.position()\n    \n    drive_input = cubic_drive(axis3)\n    turn_input = cubic_drive(axis1)\n\n    left_percent = (drive_input + turn_input)\n    right_percent = (drive_input - turn_input)\n\n    left_percent = max(-100, min(100, left_percent))\n    right_percent = max(-100, min(100, right_percent))\n\n    return (\n        0 if abs(left_percent) < DEADBAND else left_percent,\n        0 if abs(right_percent) < DEADBAND else right_percent\n    )\n\n# ðŸš€ GLOBAL STATE VARIABLE\n# State: 0 = Stopped/Idle, 1 = Intake FORWARD, -1 = Intake REVERSE\nIntakeState = 0 \n\n# ðŸ“ž CALLBACK FUNCTIONS (R2/L2 for toggling the state)\ndef intake_forward_pressed():\n    global IntakeState\n    # If the state is already forward, stop it (toggle), otherwise set it to forward\n    if IntakeState == 1:\n        IntakeState = 0\n    else:\n        IntakeState = 1\n\ndef intake_reverse_pressed():\n    global IntakeState\n    # If the state is already reverse, stop it (toggle), otherwise set it to reverse\n    if IntakeState == -1:\n        IntakeState = 0\n    else:\n        IntakeState = -1\n\n\n# Map the callbacks to the R2 and L2 buttons (These functions run ONCE when the button is pressed)\ncontroller_1.buttonL2.pressed(intake_forward_pressed)\ncontroller_1.buttonR2.pressed(intake_reverse_pressed)\n\n# âš™ï¸ MODIFIED INTAKE CONTROL FUNCTION (Runs continuously in drive_task)\ndef control_intake():\n    # 1. R1 and L1 have PRIORITY (Momentary Stop/Run)\n    if controller_1.buttonR1.pressing():\n        motors[\"front_intake\"].spin(REVERSE, 100, PERCENT)\n        motors[\"top_roller\"].spin(REVERSE, 100, PERCENT)\n        # Manually override the state for momentary control\n        global IntakeState\n        IntakeState = 0 \n    elif controller_1.buttonL1.pressing():\n        motors[\"front_intake\"].spin(FORWARD, 100, PERCENT)\n        motors[\"top_roller\"].spin(FORWARD, 100, PERCENT)\n        # Manually override the state for momentary control\n        global IntakeState\n        IntakeState = 0\n    \n    # 2. If NO momentary button is pressed, use the global state set by R2/L2\n    elif IntakeState == 1: # Intake FORWARD (L2 pressed)\n        motors[\"front_intake\"].spin(FORWARD, 100, PERCENT)\n        motors[\"top_roller\"].spin(FORWARD, 100, PERCENT)\n    elif IntakeState == -1: # Intake REVERSE (R2 pressed)\n        motors[\"front_intake\"].spin(REVERSE, 100, PERCENT)\n        motors[\"top_roller\"].spin(REVERSE, 100, PERCENT)\n    \n    # 3. If R1/L1 are not pressed and IntakeState is 0, stop the motors\n    else:\n        motors[\"front_intake\"].stop(BrakeType.BRAKE) \n        motors[\"top_roller\"].stop(BrakeType.BRAKE)\n\ndef drive_task():\n    while True:\n        left, right = get_drive_values()\n        motors[\"left_drive\"].spin(REVERSE, left, PERCENT)\n        motors[\"right_drive\"].spin(REVERSE, right, PERCENT)\n        control_intake()\n        sleep(15)\n\n# Display Motor Data\ndef display_motor_data(motor, index):\n    xpos = index * 48\n    ypos = 0\n\n    brain.screen.set_font(FontType.MONO15)\n\n    if not motor.installed():\n        brain.screen.set_fill_color(COLORS[\"grey\"])\n    elif motor is motors[\"left_drive\"]:\n        brain.screen.set_fill_color(COLORS[\"lblue\"])\n    elif motor is motors[\"right_drive\"]:\n        brain.screen.set_fill_color(COLORS[\"lred\"])\n    else:\n        brain.screen.set_fill_color(COLORS[\"dgrey\"])\n\n    brain.screen.set_pen_color(Color.WHITE)\n    brain.screen.draw_rectangle(xpos, ypos, 49 if index < 9 else 48, 79)\n\n    if not motor.installed():\n        brain.screen.print_at(\"NC\", x=xpos+15, y=ypos+30)\n        return\n\n    brain.screen.print_at(\"%02d\" % (index+1), x=xpos+13, y=ypos+13)\n    brain.screen.set_pen_color(Color.YELLOW)\n    brain.screen.print_at(\"%4d\" % motor.velocity(RPM), x=xpos+13, y=ypos+30)\n    brain.screen.print_at(\"%5.1f\" % motor.position(TURNS), x=xpos+5, y=ypos+45)\n    brain.screen.print_at(\"%4.1fA\" % motor.current(), x=xpos+5, y=ypos+60)\n    brain.screen.print_at(\"%4.0fC\" % motor.temperature(), x=xpos+5, y=ypos+75)\n    brain.screen.set_pen_color(Color.WHITE)\n    brain.screen.draw_line(xpos, ypos+14, xpos+48, ypos+14)\n\n# Display Task\ndef display_task():\n    brain.screen.set_font(FontType.PROP20)\n    brain.screen.set_pen_color(Color.RED)\n    brain.screen.print_at(\"TEST DRIVE CODE\", x=90, y=160)\n\n    motor_list = list(motors.values())\n    while True:\n        for index, motor in enumerate(motor_list):\n            display_motor_data(motor, index)\n        brain.screen.render()\n        sleep(10)\n\n# Autonomous Task\ndef autonomous_task():\n    brain.screen.print(\"Auton Started\")\n    drive_task()\n\n# Start Threads and Competition\nThread(display_task)\ncomp = Competition(drive_task, autonomous_task)","textLanguage":"python","robotConfig":[],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.62.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null}}